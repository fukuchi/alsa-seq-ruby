#!/usr/bin/env ruby

require './alsa_midi'

#0.upto(256) do |i|
i = SND_SEQ_PORT_CAP_SUBS_READ | SND_SEQ_PORT_CAP_READ
  begin
    midi = AlsaMidi.new( 'try again', i )
    midi.connect_out_to(134, 0)
    midi.write_note(1, i, 100, 250)
    puts "#{i} !"
  rescue => e
    if $err != -22 && $err != -16 && $err != -12
      puts "#{i} => #{$err}"
    end
  end
#end
p midi


 midi.write_note(1, 64, 100, 250)
# midi.echo

#midi.connect_in_to(133, 0)

# midi.connect_out_to(134, 0)
 midi.write_note(1, 64, 100, 250)

while ev = midi.read_event
  p ev
end

__END__




handle = midi_open

def ev_type(i)
  EVENT_TYPES.invert[i]
end

def ev_create
  pointer = FFI::MemoryPointer.new :pointer, AlsaSeq::Event.size
  ev = AlsaSeq::Event.new pointer
  ev_init(ev)
end

def ev_init( ev)
  ev[:source][:client] = 128
  ev[:source][:port] = @out
  #define set_subs
  ev[:dest][:client] = SND_SEQ_ADDRESS_SUBSCRIBERS
  ev[:dest][:port] = SND_SEQ_ADDRESS_UNKNOWN
  ev[:queue] = SND_SEQ_QUEUE_DIRECT
  ev
end

def ev_copy( ev )
  ev2 = ev_create
  ev2[:type] = ev[:type]
  [ :channel, :note, :velocity, :off_velocity, :duration ].each do |s|
    ev2[:data][:note][s] = ev[:data][:note][s]
  end
  ev2
end

def puts_ev( ev )
  keys = [ :channel, :note, :velocity, :off_velocity, :duration ]
  print ev_type( ev[:type] ).to_s + "\t"
  print(keys.map do |k|
    "#{k} : %d" % ev[:data][:note][k]
  end.join(' / '))
  [ :source, :dest ].each do |sd|
    print " / #{sd} %d:%d" % [ ev[sd][:client], ev[sd][:port] ]
  end
  print " / queue #{ev[:queue]}"
  puts
end

while true
  previous = nil
  ev = get_input_event(handle)
  puts_ev(ev)

  if ev_type( ev[:type] ) == :SND_SEQ_EVENT_NOTEON
    ev = ev_init(ev)
    ev[:type] = EVENT_TYPES[:SND_SEQ_EVENT_NOTE]
    ev[:data][:note][:duration] = 250
    ev[:data][:note][:off_velocity] = ev[:data][:note][:velocity]

    puts_ev( ev )
    begin
      check { AlsaSeq.event_output_direct(handle, ev) }
    rescue => e
      puts e
    end
    begin
      check { AlsaSeq.event_output_direct(handle, ev.pointer) }
    rescue => e
      puts e
    end

    ev[:source][:port]=@in

    begin
      check { AlsaSeq.event_output_direct(handle, ev) }
    rescue => e
      puts e
    end
    begin
      check { AlsaSeq.event_output_direct(handle, ev.pointer) }
    rescue => e
      puts e
    end

  end

  #previous = ev
  #if previous
  #  previous[:type] = EVENT_TYPES[:SND_SEQ_EVENT_NOTEOFF]
  #  check { AlsaSeq.event_ouput(handle, previous) }
  #end

end
